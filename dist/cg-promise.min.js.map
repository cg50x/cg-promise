{"version":3,"file":"cg-promise.min.js","sources":["../cg-promise.ts"],"sourcesContent":["enum Status {\n  Rejected,\n  Resolved,\n  Pending\n};\n\nexport default class CGPromise {\n  private status = Status.Pending;\n  private payload = null;\n  private thenCallbacks = [];\n  private errCallbacks = [];\n\n  public static resolve: any;\n  public static reject: any;\n  public static all: any;\n\n  constructor(cb) {\n    setTimeout(() => {\n      cb(val => this.resolve(val), err => this.reject(err));\n    });\n  }\n  \n  then(cb) {\n    // resolve with the value immediately\n    // or add it to a list of callbacks which will get called later\n    if (this.status === Status.Resolved) {\n      return new CGPromise((resolve, reject) => {\n        const thenCb = this.getAction(resolve, reject, cb);\n        thenCb(this.payload);\n      });\n    } else if (this.status === Status.Rejected) {\n      return new CGPromise((resolve, reject) => {\n        reject(this.payload);\n      });\n    } else {\n      return new CGPromise((resolve, reject) => {\n        const thenCb = this.getAction(resolve, reject, cb);\n        this.thenCallbacks.push(thenCb);\n        this.errCallbacks.push(() => {\n          reject(this.payload);\n        });\n      });\n    }\n  }\n\n  catch(cb) {\n    // resolve with the value immediately\n    // or add it to a list of callbacks which will get called later\n    if (this.status === Status.Rejected) {\n      return new CGPromise((resolve, reject) => {\n        const errCb = this.getAction(resolve, reject, cb);\n        errCb(this.payload);\n      });\n    } else if (this.status === Status.Resolved) {\n      return new CGPromise((resolve) => {\n        resolve(this.payload);\n      });\n    } else {\n      return new CGPromise((resolve, reject) => {\n        const errCb = this.getAction(resolve, reject, cb);\n        this.errCallbacks.push(errCb);\n        this.thenCallbacks.push(() => {\n          resolve(this.payload);\n        });\n      });\n    }\n  }\n\n  private reject(err) {\n    if (this.status !== Status.Pending) {\n      return;\n    }\n    this.status = Status.Rejected;\n    this.payload = err;\n    this.errCallbacks.forEach((cb) => {\n      cb(this.payload);\n    });\n  }\n\n  private resolve(val) {\n    if (this.status !== Status.Pending) {\n      return;\n    }\n    this.status = Status.Resolved;\n    this.payload = val;\n    this.thenCallbacks.forEach((cb) => {\n      cb(this.payload);\n    });\n  }\n  \n  private getAction(resolve, reject, cb) {\n    return (newPayload) => {\n      try {\n        const result = cb(newPayload);\n        if (result instanceof CGPromise) {\n          result.then(resolve);\n          result.catch(reject);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    };\n  }\n}\n\nCGPromise.resolve = function (value) {\n  return new CGPromise(function (resolve) {\n    resolve(value);\n  });\n};\n\nCGPromise.reject = function (error) {\n  return new CGPromise(function (resolve, reject) {\n    reject(error);\n  });\n};\n\nCGPromise.all = function (promises) {\n  promises = promises || [];\n  return new CGPromise(function (resolve, reject) {\n    // Waiting until all results to complete\n    var results = new Array(promises.length);\n    var numComplete = 0;\n    promises.forEach((promise, index) => {\n      promise.then((val) => {\n        results[index] = val;\n        numComplete += 1;\n        if (numComplete === promises.length) {\n          resolve(results);\n        }\n      });\n    });\n    // If any of them error out, reject the promise.\n    promises.forEach((promise) => {\n      promise.catch(function (err) {\n        reject(err);\n      });\n    });\n  });\n};\n"],"names":["Status","cb","this","Pending","setTimeout","val","_this","resolve","err","reject","CGPromise","status","Resolved","getAction","payload","Rejected","thenCb","thenCallbacks","push","errCallbacks","errCb","forEach","newPayload","result","then","catch","value","error","all","promises","results","Array","length","numComplete","promise","index"],"mappings":"qLAAA,IAAKA,GAAL,SAAKA,GACHA,2BACAA,2BACAA,yBAHF,CAAKA,IAAAA,OAML,iBAUE,WAAYC,GAAZ,WATQC,YAASF,EAAOG,QAChBD,aAAU,KACVA,sBACAA,qBAONE,WAAW,WACTH,EAAG,SAAAI,GAAO,OAAAC,EAAKC,QAAQF,IAAM,SAAAG,GAAO,OAAAF,EAAKG,OAAOD,OAuFtD,OAnFEE,iBAAA,SAAKT,GAAL,WAGE,OACS,IAAIS,EADTR,KAAKS,SAAWX,EAAOY,SACJ,SAACL,EAASE,GACdH,EAAKO,UAAUN,EAASE,EAAQR,GACxCK,EAAKQ,UAELZ,KAAKS,SAAWX,EAAOe,SACX,SAACR,EAASE,GAC7BA,EAAOH,EAAKQ,UAGO,SAACP,EAASE,GAC7B,IAAMO,EAASV,EAAKO,UAAUN,EAASE,EAAQR,GAC/CK,EAAKW,cAAcC,KAAKF,GACxBV,EAAKa,aAAaD,KAAK,WACrBT,EAAOH,EAAKQ,cAMpBJ,kBAAA,SAAMT,GAAN,WAGE,OACS,IAAIS,EADTR,KAAKS,SAAWX,EAAOe,SACJ,SAACR,EAASE,GACfH,EAAKO,UAAUN,EAASE,EAAQR,GACxCK,EAAKQ,UAEJZ,KAAKS,SAAWX,EAAOY,SACX,SAACL,GACpBA,EAAQD,EAAKQ,UAGM,SAACP,EAASE,GAC7B,IAAMW,EAAQd,EAAKO,UAAUN,EAASE,EAAQR,GAC9CK,EAAKa,aAAaD,KAAKE,GACvBd,EAAKW,cAAcC,KAAK,WACtBX,EAAQD,EAAKQ,cAMbJ,mBAAR,SAAeF,GAAf,WACMN,KAAKS,SAAWX,EAAOG,UAG3BD,KAAKS,OAASX,EAAOe,SACrBb,KAAKY,QAAUN,EACfN,KAAKiB,aAAaE,QAAQ,SAACpB,GACzBA,EAAGK,EAAKQ,aAIJJ,oBAAR,SAAgBL,GAAhB,WACMH,KAAKS,SAAWX,EAAOG,UAG3BD,KAAKS,OAASX,EAAOY,SACrBV,KAAKY,QAAUT,EACfH,KAAKe,cAAcI,QAAQ,SAACpB,GAC1BA,EAAGK,EAAKQ,aAIJJ,sBAAR,SAAkBH,EAASE,EAAQR,GACjC,OAAO,SAACqB,GACN,IACE,IAAMC,EAAStB,EAAGqB,GACdC,aAAkBb,GACpBa,EAAOC,KAAKjB,GACZgB,EAAOE,MAAMhB,IAEbF,EAAQgB,GAEV,MAAOf,GACPC,EAAOD,oBAMLD,QAAU,SAAUmB,GAC5B,OAAO,IAAIhB,EAAU,SAAUH,GAC7BA,EAAQmB,MAIZhB,EAAUD,OAAS,SAAUkB,GAC3B,OAAO,IAAIjB,EAAU,SAAUH,EAASE,GACtCA,EAAOkB,MAIXjB,EAAUkB,IAAM,SAAUC,GAExB,OADAA,EAAWA,MACJ,IAAInB,EAAU,SAAUH,EAASE,GAEtC,IAAIqB,EAAU,IAAIC,MAAMF,EAASG,QAC7BC,EAAc,EAClBJ,EAASR,QAAQ,SAACa,EAASC,GACzBD,EAAQV,KAAK,SAACnB,GACZyB,EAAQK,GAAS9B,GACjB4B,GAAe,KACKJ,EAASG,QAC3BzB,EAAQuB,OAKdD,EAASR,QAAQ,SAACa,GAChBA,EAAQT,MAAM,SAAUjB,GACtBC,EAAOD"}